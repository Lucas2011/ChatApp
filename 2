# Interview Questions & Answers


## Database

#### What is Core Data?

Core Data is a framework that is used to manage model layer objects. It has the ability to persist object graphs to a persistent store. Data is organized into relational entity-attribute model.

#### When would you use Core Data over NSUserDefault?

NSUserDefault is typically used to store small bits of data (settings, preferences, etc.). Core Data is used to store a large list of elements. 

#### What is a managed object context?

First, managed object context is an instance of NSManagedObjectContext. It is the central object in the Core Data stack. It is used to create and fetch managed objects, and to manage undo and redo operations. Although it is allowed to have multiple managed object contexts, there is typically at most one managed object to represent any given record in a persistent store.

#### What is NSFetchRequest?

NSFetchRequest is the class responsible for fetching from Core Data. Fetch requests can be used to fetch a set of objects meeting a certain criteria, individual values and more. ([source](https://medium.com/ios-os-x-development/50-ios-interview-questions-and-answers-part-2-45f952230b9f))

## Debugging

#### What are some ways of debugging in iOS?

- NSLog and print functions can be used for output into console.
- Breakpoints can also be used together with the Debug bar and Variables view as an alternative.
- Senior devs often use other tools such as Instruments and Crash Logs instead of the two above.

## Design Patterns

#### What is Singleton Pattern?

The Singleton design pattern ensures that only one instance exists for a given class and that there’s a global access point to that instance. It usually uses lazy loading to create the single instance when it’s needed the first time. ([source](https://medium.com/ios-os-x-development/ios-interview-questions-13840247a57a))

#### What is the delegation pattern? 

The delegation pattern is a powerful pattern used in building iOS applications. The basic idea is that one object will act on another object's behalf or in coordination with another object. The delegating object typically keeps a reference to the other object (delegate) and sends a message to it at the appropriate time. It is important to note that they have a one to one relationship.

#### What is MVC?

MVC stands for **Model-View-Controller**. It is a software architecture pattern for implementing user interfaces. 

MVC consists of three layers: the model, the view, and the controller.
- The **model layer** is typically where the data resides (persistence, model objects, etc)
- The **view layer** is typically where all the UI interface lies. Things like displaying buttons and numbers belong in the view layer. The view layer does not know anything about the model layer and vice versa.
- The **controller (view controller)** is the layer that integrates the view layer and the model layer together. 

#### What is MVVM?

MVVM stands for **Model-View-ViewModel**. It is a software architecture pattern for implementing user interfaces.

MVVM is an augmented version of MVC where the presentation logic is moved out of the controller and into the view model. The view model is responsible for handling most, if not all, of the view's display logic. 

A common occurence in MVC is where you have a massive-view-controller (some joke this is what MVC stands for). In order to shrink the size of your view controller and make the logic and readibility of your code easier to follow along, the MVVM will be used. 

## General / Uncategorized

#### What considerations do you need when writing a UITableViewController which shows images downloaded from a remote server?

- Only download the image when the cell is scrolled into view (when cellForRowAtIndexPath is called)
- Download the image asynchronously on a background thread so as not to block the UI so the user can keep scrolling
- When the image has downloaded for a cell, check if that cell is still in the view or whether it has been re-used by another piece of data. If the cell has been re-used, then the image should be discarded. Otherwise, it should be switched back to the main thread to change the image on the cell. ([source](https://www.codementor.io/mattgoldspink/ios-interview-tips-questions-answers-objective-c-du1088nfb))

#### What is a protocol? How do you define your own protocol? 

A protocol defines a list of required and optional methods for a class that adopts the protocol to implement. Any class is allowed to implement a protocol so that other classes can send message to it based on the protocol methods without knowing the type of class. An example of how a protocol is defined:

<details open>
<summary>Objective-C</summary>
    
```objective-c
@protocol MyCustomDataSource
- (NSUInteger)numberOfRecords;
- (NSDictionary *)recordAtIndex:(NSUInteger)index;
@optional
- (NSString *)titleForRecordAtIndex:(NSUInteger)index;
@end
```
</details>

A common instance protocols are used is providing a DataSource for UITableView or UICollectionView ([source](https://www.codementor.io/mattgoldspink/ios-interview-tips-questions-answers-objective-c-du1088nfb))

#### What is waterfall methodology and Agile methodology? What are the differences between them?

Waterfall methodology is a sequential model for software development. It is separated into a sequence of pre-defined phases including feasibility, planning, design, build, test, production, and support.

On the other hand, Agile development methodology is a linear sequential apporach that provides flexibility for changing project requirements.

List of differences:
- Waterfall model divides software development process into different phases while Agile segregates the project development lifecycle into sprints. This makes waterfall more rigid while agile allows for more flexibility
- Waterfall model describes the software development life cycle as a single project while Agile considers it as a collection of many different projects; are iterations of different phases focusing on improving overall software quality with feedback from users and QA team.
- Since waterfall is more rigid, development requirements need to be clearly established beforehand since there is little flexibility for changing once project development starts. Meanwhile, Agile allow changes to be made anytime along the project development process even after initial planning has been completed.
- In Waterfall, the testing phase typically occurs after the build phase. In Agile, testing is often performed concurrently with programming or at least in the same iteration.
- Waterfall is more of an interal process that does not involve user feedback. Agile tends to involve user participation more in order to improve customer satisfaction.
- Waterfall model best fits projects that have a clearly defined set of requirements and where change to requirements is not expect. Agile fits more for projects where the requirements are expected to change and evolve.
- Waterfall can exhibit a project mindset that focuses on completion of the project while Agile can allow for more focus on developing a product that satisfies customers.

#### What is the difference between a class and an object?

In the simplest sense, a class is a blueprint for an object. It describes the properties and behaviors common to any particular type of object. An object, on the other hand, is an instance of a class.

#### What is JSON? What are the pros and cons?

JSON stands for JavaScript Object Notation. According to [wiki](https://en.wikipedia.org/wiki/JSON), it is a file format that uses human-readable text to transmite data objects consisting of attribute-value pairs and array data types. 

Pros:

- It is lighter than XML meaning that it can represent the same data in XML in fewer bytes. This makes network transmissions and read/writes faster
- Since it is native to JavaScript, computationally-expensive XSL tranformations are not needed in order to extract data

Cons:

- Not as widespread as XML
- Data is not readily streamable and has to be broken up into individual objects
- Can't use comments

#### What is the difference between not-running, inactive, active, background and suspended execution states?**

- **Not-running state** occurs when the app either has not be launched or was running but was terminated by the system.
- **Inactive state** occurs where the app runs in the foreground but is currently not receiving events. (It may be executing other code though). This state is typically brief as apps transitions to other states.
- **Active state** is where the app is running in the foreground and receiving events. This is the normal mode for foreground apps.
- **Background state** occurs when the app is in the background and executing code. Apps typically enter this state on their way to being suspended. Apps that require extra execution time may remain in this screen longer. Apps being launched directly into the background enters this state instead of inactive state.
- **Suspended state** is where the app is in the background but it is not executing code. Apps will remain in memory, but are removed by the system if low-memory condition occurs in order to make more space for foreground apps.

#### Is it faster to iterate through an NSArray or an NSSet?

It depends. NSSet is faster to iterate through if the order of the items in the collection is not important. The reason is because NSSet uses hash values in order to find items while NSArray has to iterate through its entire contents to find a particular object. ([source - #25](https://medium.com/cocoaacademymag/25-ios-interview-questions-and-answers-for-junior-developers-19bfe6e99b0))

#### What is KVO?

KVO stands for *Key-Value Observing*. It allows a controller or class to *observe* when a property value changes. 

## Memory Management

#### Why do you generally create a weak reference when using self in a block?

Sometimes it is necessary it capture self in a block such as when defining a callback block. However, since blocks maintain strong references to any captured objects including self, this may lead to a strong reference cycle and memory leak.

Instead, capturing a weak reference to self is recommended in order to avoid this issue:

<details open>
<summary>Objective-C</summary>

```objective-c
SomeBlock* __weak weakSelf = self;
```
</details>


#### What is memory management handled on iOS?

iOS uses something called ARC which stands for Automatic Reference Counting. When an object is said to have a strong reference to it, ARC increase its retain count by 1. When the retain count of an object reaches 0, the object will typically be deallocated if there are no more strong references to it. Unlike garbage collection, ARC does not handle reference cycles automatically. 

#### What is the difference between *weak* and *strong*?

First, objects are *strong* by default.

- *Strong* means that the reference count will be increased and the reference to it will be maintained through the life of the object. 
- *Weak*, means that we are pointing to an object but not increasing its reference count. It’s often used when creating a parent child relationship. The parent has a strong reference to the child but the child only has a weak reference to the parent. ([source](https://medium.com/ios-os-x-development/ios-interview-questions-13840247a57a))

Common instances of *weak* references are delegate properties and subview/controls of a view controller's main view since those views are already strongly held by the main view. ([source](http://stackoverflow.com/questions/11013587/differences-between-strong-and-weak-in-objective-c))

#### What is a memory leak?

A memory leak commonly occurs when an object is allocated in such a way that when it is no longer in use or needed, it is not released. In iOS programming, you create certain objects with weak references in order to avoid a strong to strong relationship that creates a retain cycle and a memory leak.

#### What is a retain cycle?

Retain cycles can occur when memory management is based on retain count. This typically occurs when two objects strongly reference each other. As a result, the retain count of either object will never reach zero and deallocated from memory (hence retaining each other). 

#### What is the difference between *copy* and *retain*?

Calling *retain* on an object will increase its *retain* count by one. When the *retain* count of an objective reaches 0, the object will be deallocated and released from memory.

When you *retain* an object, you share the same version with whoever passed the object to you. But when you *copy* an object, you do not share the same version of the object that was passed to you. Instead, a duplicate of that object is created with duplicated values.

#### What is the difference between a stack vs a heap?

A stack is a region of memory where data is added or removed in a last-in-first-out (LIFO) order. According to [Ates Goral](http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap), it is the memory set aside as scratch space for a thread of execution. Meanwhile the heap is memory set aside for dynamic allocation. Unlike the stack, you can allocate a block at any time and free it at anytime. 

Note: In Objective-C, all objects are always allocated on the heap, or at least should be treated as if on the heap. 

## Networking

## Objective-C

#### What is synthesize in Objective-C?

*Synthesize* generates getter and setter methods for your property.

#### What is dynamic in Objective-C?

Dynamic is used for subclasses of NSManagedObject. @dynamic can also be used to delegate the responsibility of implementing the accessors. ([source](https://medium.com/ios-os-x-development/ios-interview-questions-13840247a57a))

#### What is the difference between _ vs self. in Objective-C?

You typically use either when accessing a property in Objective-C. When you use _, you're referencing the actual instance variable directly. You should avoid this. Instead, you should use self. to ensure that any getter/setter actions are honored. 

In the case that you would write your own setter method, using _ would not call that setter method. Using self. on the property, however, would call the setter method you implemented. 

#### What are blocks in Objective-C?

Blocks are a language-level feature of Objective (C and C++ too). They are objects that allow you to create distinct segments of code that can be passed around to methods or functions as if they were values. This means that a block is capable of being added to collections such as NSArray or NSDictionary. Blocks are also able to take arguments and return values similar to methods and functions.

The syntax to define a block literal uses the caret symbol(^):

<details open>
<summary>Objective-C</summary>
    
```objective-c
^{
  NSLog(@"This is an example of a block")
}
```
</details>

#### What is the difference between category and extension in Objective-C?

A category and extension are similar in functionality where they can add additional instance and class methods to a class. However, an extension can only do so if the source code for the class being extended is available at compile time. This means that classes such as NSString cannot be extended. Instead, a category would be used to add additional methods to the NSString class

## Swift

#### What is the difference between public and open? Why is it important to have both?

Open access imposes limitations on class inheritance. Classes declared with open level access can be subclassed by modules they are defined in, modules that import the module in which the class is defined, and class members as well. While this sounds similar to the public access level defined in Swift 2, there is a small difference. In Swift 3, the meaning of public access level means that classes declared public can only be subclassed in the module they are defined in. This includes public class members which can be overridden by subclasses defined int he module they are defined in.

Some classes of libraries and frameworks are not designed to be subclasses. For example, in the Core Data framework, Apple states that some methods of NSManagedObject should not be overridden. To prevent any unexpected behavior that may result from overriding those methods, Apple declares those methods public rather than open. As a result, those methods are not marked as open for developers to override. ([source](https://cocoacasts.com/what-is-the-difference-between-public-and-open-in-swift-3/))

#### What is the difference between *var* and *let*?

*var* is a variable that can be changed while *let* denotes a constant that cannot be changed once set.

#### What is the difference between a struct and a class?

The main difference to note is that structs are value types (stored on stack) while classes are reference types (stored on heap). 

Classes have capabilities that structs do not:
- Inheritance enables one class to inherit the characteristics of another. ([source](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html))
- Type casting enables you to check and interpret the type of a class instance at runtime.
- Deinitializers enable an instance of a class to free up any resources it has assigned.
- Reference counting allows more than one reference to a class instance.

#### What is the difference between implicit and explicit?

When referring to something as implicit or explicit, it is often referring to how an object is declared. In the two examples below:

<details open>
<summary>Swift</summary>
    
```swift
var name: String = "onthecodepath" // explicit
var name = "onthecodepath" // implicit
```
</details>

In the first line above, the name variable is *explicitly* declared since the type of the variable follows the name of the variable. In the second line, the String type is not explicitly declared. However, Swift is able to infer that name is of a String type since the value that it is being set as is of a String type.

## Thread Management

#### What is the difference between synchronous and asynchronous task?

Synchronous tasks wait until the task has been completed while asynchronous tasks can run in the background and send a notification when the task is complete.

#### What is the difference between *atomic* and *non-atomic* synthesized properties?

First, properties are set to *atomic* by default. 

*Atomic* properties are more likely to guarentee thread-safety because it will ensure that a value is fully set (by the setter method) or fully retrieved (by the getter method) when accessor methods are called simultaneously.

*Non-atomic* properties, howeer are not thread-safe. While they run faster, they may cause race conditions. In the event that accessor methods are called simultaneously and a race condition occurs, a setter value would first release the old value and a getter method would retrieve nil since no value has not been set yet.

#### What is GCD and how is it used?

GCD stands for Grand Central Dispatch. According to [Ray Wenderlich](https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1), it offers the following benefits
- Improving your app's responsiveness by helping to defer computationally expensive tasks and run them in the background.
- Providing an easier concurrency model than locks and threads and helps to avoid concurrency bugs.
- Potentially optimize your code with higher performance primitives for common patterns such as singletons.

In other words, GCD provides and manages queues of tasks in the iOS app. This is one of the most commonly used API to manage concurrent code and execute operations asynchronously. Network calls are often performed on a background thread while things like UI updates are executed on the main thread.

#### Explain the difference between Serial vs Concurrent

Tasks executed *serially* are executed one at a time while tasks that are executed *concurrently* may be executed at the same time.

#### Spot the bug that occurs in the code:

<details open>
<summary>Swift</summary>

```swift
class ViewController: UIViewController {
    @IBOutlet var alert: UILabel!
    override func viewDidLoad() {
        super.viewDidLoad()
        let frame: CGRect = CGRect(x: 100, y: 100, width: 100, height: 50)
        self.alert = UILabel(frame: frame)
        self.alert.text = "Please wait..."
        self.view.addSubview(self.alert)
    }
    DispatchQueue.global(qos: .default).async {
        sleep(10)
        self.alert.text = "Waiting over"
    }
}
```
</details>

<details>
<summary>Objective-C</summary>

```objective-c
@interface MyCustomController : UIViewController  
@property (strong, nonatomic) UILabel *alert;  
@end  

@implementation MyCustomController  

- (void)viewDidLoad {
  CGRect frame = CGRectMake(100, 100, 100, 50);
  self.alert = [[UILabel alloc] initWithFrame:frame];
  self.alert.text = @"Please wait...";
  [self.view addSubview:self.alert];
  dispatch_async(
    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),
    ^{
      sleep(10);
      self.alert.text = @"Waiting over";
    }
  ); 
}  
```
</details>
<br>

All UI updates must be performed on the main thread. Global dispatch queues do not make any guarantees so code should be modified to run the UI update on the main thread. Here is the fix below:


<details open>
<summary>Swift</summary>

```swift
DispatchQueue.global(qos: .default).async {
    sleep(10)
    DispatchQueue.main.async {
        self.alert.text = "Waiting over"
    }
}
```
</details>

<details>
<summary>Objective-C</summary>
    
```
dispatch_async(		
dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),
^{
    sleep(10);
    dispatch_async(dispatch_get_main_queue(), ^{
        self.alert.text = @"Waiting over";
    });
}); 

```
</details>

## Unit Testing / UI Testing

#### What is the purpose of unit/UI testing? What are the benefits?

Unit/UI testing are the basic of test-driven development. This development approach allows you to codify requirements for your code before you implement it. Unit tests are important to make sure that code meets its design and requirements and behaves as expected. Parts of the program are segregated and tested to ensure that individual parts are working correctly. 

## View / Storyboard

#### What is the difference between viewDidLoad and viewDidAppear? Which should you use to load data from a remote server to display in the view?

viewDidLoad is only called when the view is loaded (after loadView is called). viewDidAppear, on the other hand, is called everytime the view appears on the device. 

If the data is static for the most part, it can be loaded in viewDidLoad and cached. But if the data is dynamic and likely to change often, it is preferrable to use viewDidAppear. In both instances, data should be loaded asynchronously on a background thread to avoid blocking the UI.

#### What is the difference between frame and bound of a UIView?

The *frame* of a UIView is the region relative to the superview it is contained within while the *bounds* of a UIView is the region relative to its own coordinate system.

#### What is the reuseIdentifier for?

The *reuseIdentifier* indicates that cells for a UITableView (or UICollectionView) can be reused. UITableView maintains an internal cache of UITableViewCell with the appropriate identifier and allows them to be reused when dequeueForCellWithReuseIdentifier is called. As a result, this increases performance of UITableView since a new view does not have to be created for a cell.

#### What is autolayout?

Auto Layout is used to dynamically calculate the size and position of views based on constraints.

# Algorithm Resources

#### [EKAlgorithm](https://github.com/EvgenyKarkan/EKAlgorithms): Algorithm and data structures in Objc

#### [swift-algorithm-club](https://github.com/raywenderlich/swift-algorithm-club): Algorithm and data structures in Swift

# Contributing

#### There's a typo / an incorrect answer to one of your questions

Great! Creating an issue will let me know what changes should be made. You can even making the changes yourself and make a pull request which will expedite the process!

#### Requesting questions to be answered and topics

If you open an issue, I would be happy to go ahead and add the question with the appropriate answer when I get to it!

1. IOS Characteristics
Criteria	Result
Type of Operating System	Apple Proprietary based on Macintosh OS X
OS Fragmentation	Tightly integrated with Apple devices
Security	Heightened security guaranteed
2. What JSON framework is supported by iOS (iPhone OS)?
SBJson framework is supported by iOS. It is a JSON parser and generator for Objective-C (Objective-C is the primary programming language you use when writing software for OS X and iOS. It’s a superset of the C programming language and provides object-oriented capabilities and a dynamic runtime).
SBJson provides flexible APIs and additional control that makes JSON handling easy.
3. How can we prevent iOS 8 app's streaming video media from being captured by QuickTime Player on Yosemite during screen recording?
HTTP Live Streams that have their media encrypted will not be recorded by QuickTime Player on Yosemite while screen recording. These will black out in the recording.
• HTTP Live Streaming: – Send live and on‐demand audio and video to iPhone, iPad, Mac, Apple TV, and PC with HTTP Live Streaming (HLS) technology from Apple. Using the same protocol that powers the web, HLS lets you deploy content using ordinary web servers and content delivery networks. HLS is designed for reliability and dynamically adapts to network conditions by optimizing playback for the available speed of wired and wireless connections.
Become iOS Certified in 16 hrs.
GET CERTIFIED
4. Name the framework that is used to construct application’s user interface for iOS
The UIKit framework is used to develop application’s user interface. The UIKit framework provides event handling, drawing model, windows, views, and controls, specifically designed for a touch screen interface.
The UIKit framework (UIKit.framework) provides the crucial infrastructure needed to construct and manage iOS apps. This framework provides:
-> window and view architecture to manage an app’s user interface,
-> event handling infrastructure to respond to user input, and
-> an app model to drive the main run loop and interact with the system.
In addition to the core app behaviors, UIKit provides support for the following features:
✓ A view controller model to encapsulate the contents of your user interface
✓ Support for handling touch and motion-based events
✓ Support for a document model that includes iCloud integration
✓ Graphics and windowing support, including support for external displays
✓ Support for managing the app’s foreground and background execution
✓ Printing support
✓ Support for customizing the appearance of standard UIKit controls
✓ Support for text and web content
✓ Cut, copy, and paste support
✓ Support for animating user-interface content
✓ Integration with other apps on the system through URL schemes and framework interfaces
✓ Accessibility support for disabled users
✓ Support for the Apple Push Notification service
✓ Local notification scheduling and delivery
✓ PDF creation
✓ Support for using custom input views that behave like the system keyboard
✓ Support for creating custom text views that interact with the system keyboard
✓ Support for sharing content through email, Twitter, Facebook, and other services
Check this tutorial, to learn more about iOS user interface.
5. How can you respond to state transitions on your app?
State transitions can be responded to state changes in an appropriate way by calling corresponding methods on app’s delegate object.
For example:
applicationDidBecomeActive( ) method can be used to prepare to run as the foreground app.
applicationDidEnterBackground( ) method can be used to execute some code when the app is running in the background and may be suspended at any time.
applicationWillEnterForeground( ) method can be used to execute some code when your app is moving out of the background
applicationWillTerminate( ) method is called when your app is being terminated.
6. What are the features added in iOS 9?
Intelligent Search and Siri- Intelligent Search is an excellent mechanism to learn user habits and act on that information- open apps before we need them, make recommendations on places we might like and guide us through our daily lives to make sure we’re where we need to be at the right time.
Siri is a personal assistant to the users, able to create contextual reminders and search through photos and videos in new ways. Swiping right from the home screen also brings up a new screen that houses “Siri Suggestions,” putting favorite contacts and apps right on your fingertips, along with nearby restaurant and location information and important news.
Deeper search capabilities can show results like sports scores, videos, and content from third-party apps, and you can even do simple conversions and calculations using the search tools on your iPhone or iPad.Performance improvements
Many of the built-in apps have been improved.
✓ Notes includes new checklists and sketching features
✓ Maps now offers transit directions
✓ Mail allows for file attachments, and
✓ New “News” app that learns your interests and delivers relevant content you might     like to read.
✓ Apple Pay is being improved with the addition of store credit cards and loyalty cards
✓ Leading “Passbook” to be renamed to “Wallet” in iOS 9.
San Francisco font, wireless CarPlay support
An optional iCloud Drive app, built-in two-factor authentication and optional longer passwords for better security.
7. What is the difference between retain & assign?
Assign creates a reference from one object to another without increasing the source’s retain count.
if (_variable != object)
{   	
 [_variable release];  
  _variable = nil;  
  _variable = object;
 }
Retain creates a reference from one object to another and increases the retain count of the source object.
if (_variable != object)
{
  [_variable release];
    _variable = nil;  
_variable = [object retain];  
}
8. What are the different ways to specify layout of elements in UIView?
Here are a few common ways to specify the layout of elements in UIView:
• Using InterfaceBuilder, you can add an XIB file to your project, layout elements within it, and then load the XIB in your application code (either automatically, based on naming conventions, or manually). Also, using InterfaceBuilder you can create a storyboard for your application.
• You can write your own code to use NSLayoutConstraints and have elements in a view arranged by Auto Layout.
• You can create CGRects describing the exact coordinates for each element and pass them to UIView’s – (id)initWithFrame:(CGRect)frame method.
Click here, to learn more about the layout of elements in UIView.
9. What is the difference between atomic and non-atomic properties? Which is the default for synthesized properties? When would you use one over the other?
Properties specified as atomic are guaranteed to always return a fully initialized object. This also happens to be the default state for synthesized properties.
While it’s a good practice to specify atomic to remove the potential for confusion, if you leave it off, your properties will still be atomic.
This guarantee of atomic properties comes at the cost of performance.
However, if you have a property for which you know that retrieving an uninitialized value is not a risk (e.g. if all access to the property is already synchronized via other means), setting it to non-atomic can boost performance.
Learn iOS from Experts! Enrol Today
10. Describe managed object context and it's function.
A managed object context (represented by an instance of NSManagedObjectContext) is a temporary “scratchpad” in an application for a (presumably) related collection of objects. These objects collectively represent an internally consistent view of one or more persistent stores.
A single managed object instance exists in one and only one context, but multiple copies of an object can exist in different contexts.
The key functions of managed object context include
 Life-cycle management: Here, the context provides validation, inverse relationship handling and undo/redo
 Notifications refer to context posts notifications at various points that can be optionally monitored elsewhere in your application.
 Concurrency is when the Core Data uses thread (or serialized queue) confinement to protect managed objects and managed object contexts.
Learn more about iOS from this tutorial.
11. Explain Singleton class.
Only one instance of that class is created in the application.
@interface SomeManager : NSObject
             + (id)singleton;
 @end
 @implementation SomeManager
            + (id)singleton {    
                                 static id sharedMyManager = nil; 
                                 @synchronized([MyObject class]){ 
                                                     if (sharedMyManager == nil) { 
                                                                         sharedMyManager = [[self alloc] init]; 
                                                      } 
                                 }
                                return sharedMyManager;
            }
 @end
//using block
+ (id) singleton {
    static SomeManager *sharedMyManager = nil;
    static dispatch_once_t  onceToken;
dispatch_once(&onceToken, ^{
        sharedMyManager = [[self alloc] init];
    });
    return sharedMyManager;
}
12. What is unnamed category
Unnamed Category has fallen out of favor now that @protocol has been extended to support @optional methods.
A class extension –
@interface Foo() — is designed to allow you to declare additional private API — SPI or System Programming Interface — that is used to implement the class innards. This typically appears at the top of the .m file. Any methods/properties declared in the class extension must be implemented in the @implementation, just like the methods/properties found in the public @interface.
Class extensions can also be used to re-declare a publicly readonly @property as readwrite prior to @synthesize’ing the accessors.
Example:
Foo.h
@interface Foo:NSObject
@property(readonly, copy) NSString *bar;
-(void) publicSaucing;
@end
Foo.m
@interface Foo()
@property(readwrite, copy) NSString *bar;
- (void) superSecretInternalSaucing;
@end
@implementation Foo
@synthesize bar;
.... must implement the two methods or compiler will warn ....
@end
13. Does Objective-C contain private methods?
NO, there is nothing called a private method in Object-C programming. If a method is defined in .m only then it becomes protected. If in .h,it is public.
If you really want a private method then you need to add a local category/ unnamed category/ class extension in the class and add the method in the category and define it in the class.m.
Click here, to learn more about Objective-C.
14. What is plist?
Plist refers to Property lists that organize data into named values and lists of values using several object types. These types provide you the means to produce data that is meaningfully structured, transportable, storable, and accessible, but still as efficient as possible. Property lists are frequently used by applications running on both Mac OS X and iOS. The property-list programming interfaces for Cocoa and Core Foundation allow you to convert hierarchically structured combinations of these basic types of objects to and from standard XML. You can save the XML data to disk and later use it to reconstruct the original objects.
The user defaults system, which you programmatically access through the NSUserDefaults class, uses property lists to store objects representing user preferences. This limitation would seem to exclude many kinds of objects like as NSColor and NSFont objects, from the user default system. But if objects conform to the NSCoding protocol they can be archived to NSData objects, which are property list–compatible objects.
Click here, to learn about iOS online training course.
15. What is the purpose of reuseIdentifier? What is the benefit of setting it to a non-nil value?
The reuseIdentifier is used to group together similar rows in a UITableView; i.e., rows that differ only in their content, but otherwise have similar layouts.
A UITableView will normally allocate just enough UITableViewCell objects to display the content visible in the table.
 If reuseIdentifier is set to a non-nil value then UITableView will first attempt to reuse an already allocated UITableViewCell with the same reuseIdentifier when the table view is scrolled.
 If reuseIdentifier has not been set, the UITableView will be forced to allocate new UITableViewCell objects for each new item that scrolls into view, potentially leading to laggy animations.
16. What is the difference between an “app ID” and a “bundle ID” and what is each used for?
An App ID is a two-part string to identify one or more apps from a single development team. The string consists of a Team ID and a bundle ID search string, with a period (.) separating the two parts.
The Team ID is supplied by Apple and is unique to a specific development team while a bundle ID search string is supplied by the developer to match either the bundle ID of a single app or a set of bundle IDs for a group of apps.
Since most users consider the App ID as a string, they think it is interchangeable with Bundle ID. Once the App ID is created in the Member Center, you can only use the App ID Prefix that matches the Bundle ID of the Application Bundle.
The bundle ID uniquely defines each App. It is specified in Xcode. A single Xcode project can have multiple targets and therefore, output multiple apps. A common use case for this – An app having both lite/free and pro/full versions or branded multiple ways.
17. What is Abstract class in Cocoa?
Cocoa doesn’t provide anything called abstract. We can create a class abstract that gets checked only at runtime while it is not checked at compile time.
@interface AbstractClass : NSObject
@end
@implementation AbstractClass
+ (id)alloc{
    if (self == [AbstractClass class]) {
        NSLog(@"Abstract Class can’t be used");
    }
    return [super alloc];
@end
18. What is NSURLConnection class? Define its types and use case.
There are two ways of using NSURLConnection class. One is asynchronous and the other is synchronous.
An asynchronous connection will create a new thread and performs its download process on the new thread. A synchronous connection will block the calling thread while downloading content and doing its communication.
Many developers think that a synchronous connection blocks the main thread, which is not true. A synchronous connection will always block the thread from which it is fired. If you fire a synchronous connection from the main thread, the main thread will be blocked. But, if you fire a synchronous connection from a thread other than the main thread, it will be like an asynchronous connection and won’t block your main thread.
In fact, the only difference between a synchronous and an asynchronous connection is that at runtime, a thread will be created for the asynchronous connection while it won’t do the same for a synchronous connection.
In order to create an asynchronous connection, we need to do the following:
1. Have our URL in an instance of NSString
2. Convert our string to an instance of NSURL
3. Place our URL in an URL Request of type NSURLRequest, or in the case of mutable URLs, in an instance of NSMutableURLRequest.
4. Create an instance of NSURLConnection and pass the URL request to it.
Learn more about iOS, in this iOS online training course.
19. What is the relation between iVar and @property?
iVar is an instance variable. It cannot be accessed unless we create accessors, which are generated by @property. iVar and its counterpart @property can be of different names.
@interface Box : NSObject{
    NSString *boxName;
}
@property (strong) NSString *boxDescription;//this will become another ivar
-(void)aMethod;
@end
@implementation Box
@synthesize boxDescription=boxName;//now boxDescription is accessor for name
-(void)aMethod {
    NSLog(@"name=%@", boxName);
     NSLog(@"boxDescription=%@",self.boxDescription);
    NSLog(@"boxDescription=%@",boxDescription); //throw an error
}












